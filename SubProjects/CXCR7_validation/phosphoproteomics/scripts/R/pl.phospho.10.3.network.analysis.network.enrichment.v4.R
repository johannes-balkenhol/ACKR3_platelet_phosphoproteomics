# Johannes Balkenhol, MIT License

#### Script Overview ####
# This script performs network preparation, clustering, and enrichment analysis.
# Aim is to find network modules defined by their interaction using different interaction-based clustering method
# the newly defined clustering are annotated by a classical gene set enrichment (GO, Reactome, or GO)
# It is designed for automation, with clear definitions of input and output files.

#### Inputs ####
# 1. interactions.intact.all.refined.platelets: Data frame containing protein-protein interactions with scores.
# 2. proteins_to_test: Vector of protein IDs to check for representation in the network.
# 3. cluster_df_mcl: Data frame containing clusters generated by automated MCL clustering.
# 4. cluster_df_cytoscape: Data frame containing clusters generated by Cytoscape.

#### Outputs ####
# 1. network_edges.txt: File containing the edge list used for MCL clustering.
# 2. cluster_results_mcl.csv: CSV file containing MCL clustering results.
# 3. Enrichment analysis results: Printed to console, organized by clusters for GO, KEGG, and Reactome.

#### Required Packages ####
if (!requireNamespace("BiocManager", quietly = TRUE))
  install.packages("BiocManager")
if (!require("clusterProfiler")) BiocManager::install("clusterProfiler")
if (!require("org.Hs.eg.db")) BiocManager::install("org.Hs.eg.db")
if (!require("KEGGREST")) BiocManager::install("KEGGREST")
if (!require("fgsea")) BiocManager::install("fgsea")
if (!require("RCy3")) install.packages("RCy3")
if (!require("igraph")) install.packages("igraph")
if (!require("MCL")) install.packages("MCL")

# Load necessary libraries
library(igraph)
library(dplyr)
library(clusterProfiler)
library(org.Hs.eg.db)
library(ReactomePA)
library(KEGGREST)
library(fgsea)
library(MCL)
library(RCy3)

#### Data Preparation ####

# Function to prepare edges based on interaction scores
prepare_edges <- function(interactions, score_threshold = 0.6) {
  edges <- interactions %>%
    filter(score > score_threshold) %>%
    select(uniprot_id1, uniprot_id2)
  
  # Ensure bidirectional relationships
  edges <- unique(rbind(edges, edges %>% rename(uniprot_id1 = uniprot_id2, uniprot_id2 = uniprot_id1)))
  
  return(edges)
}

# Generate edge list
edges <- prepare_edges(interactions.intact.all.refined.platelets)

# Save the edge list for use in MCL clustering
write.table(edges, "network_edges.txt", sep = "\t", col.names = FALSE, row.names = FALSE, quote = FALSE)

# Convert the edge list to an igraph object
graph <- graph_from_data_frame(d = edges, directed = FALSE)

# Function to test if key proteins are represented in the network
test_proteins_in_network <- function(proteins_to_test, edges) {
  network_nodes <- unique(c(edges$uniprot_id1, edges$uniprot_id2))
  proteins_df <- data.frame(
    Protein_ID = proteins_to_test,
    In_List = proteins_to_test %in% network_nodes
  )
  return(proteins_df)
}

# Check for presence of key proteins in the network
proteins_to_test <- c("P25106", "P61073", "P49407", "P32121", "P62993", "P42345", "Q03135", "P51636", "Q7Z460", "O75122", "Q15942", "Q05209")
proteins_df <- test_proteins_in_network(proteins_to_test, edges)
print(proteins_df)

#### Clustering Methods (Automated) ####

# Function to apply clustering using different methods
apply_clustering <- function(graph, method = "mcl") {
  if (method == "infomap") {
    clusters <- cluster_infomap(graph)
  } else if (method == "walktrap") {
    clusters <- cluster_walktrap(graph)
  } else if (method == "louvain") {
    clusters <- cluster_louvain(graph)
  } else if (method == "mcl") {
    adj_matrix <- as_adjacency_matrix(graph, sparse = FALSE)
    mcl_result <- mcl(adj_matrix, addLoops = TRUE, expansion = 3, inflation = 2)
    clusters <- mcl_result$Cluster
    membership_vector <- setNames(clusters, rownames(adj_matrix))
    return(membership_vector)
  } else {
    stop("Unknown clustering method.")
  }
  
  membership_vector <- membership(clusters)
  return(membership_vector)
}

# Example usage of automated clustering methods
membership_vector_infomap <- apply_clustering(graph, method = "infomap")
membership_vector_walktrap <- apply_clustering(graph, method = "walktrap")
membership_vector_louvain <- apply_clustering(graph, method = "louvain")
membership_vector_mcl <- apply_clustering(graph, method = "mcl")

# Function to create a cluster data frame from the membership vector
create_cluster_df <- function(membership_vector) {
  cluster_df <- data.frame(
    Uniprot_ID = names(membership_vector),
    Cluster_Number = as.integer(membership_vector)
  )
  return(cluster_df)
}

# Save MCL clustering results to CSV
cluster_df_mcl <- create_cluster_df(membership_vector_mcl)
write.csv(cluster_df_mcl, "cluster_results_mcl.csv", row.names = FALSE)

#### Clustering in Cytoscape ####
# Best clustering is achieved in Cytoscape, where you can visually optimize the parameters
# Use the following steps:
# 1. Export the network data (edges) to Cytoscape.
# 2. Use Cytoscape's clustering tools (e.g., MCL, MCODE) to cluster the network.
# 3. Visually optimize the clustering parameters using the visual feedback in Cytoscape.
# 4. Export the cluster annotation table from Cytoscape.
# 5. Load the annotated clusters back into R for further analysis.

# Function to load clusters from Cytoscape
load_cytoscape_clusters <- function(file_path) {
  cluster_df <- read.delim(file_path, sep = ",", header = TRUE)
  
  cluster_df <- cluster_df %>%
    dplyr::select(Uniprot_ID = shared.name, Cluster_Number = X__mclCluster, Symbol = symbol) %>%
    na.omit()
  
  return(cluster_df)
}

# Load Cytoscape cluster results
cluster_df_cytoscape <- load_cytoscape_clusters("../../analysis/intact/pl.network.cluster.mcl.1.7.v3.csv")

#### Investigate Cluster Size ####

# Function to calculate cluster sizes
cluster_size_df <- function(cluster_df) {
  cluster_size <- cluster_df %>%
    group_by(Cluster_Number) %>%
    summarise(Protein_Count = n()) %>%
    arrange(desc(Protein_Count))
  return(cluster_size)
}

# Print cluster sizes for both MCL and Cytoscape results
print(cluster_size_df(cluster_df_mcl))
print(cluster_size_df(cluster_df_cytoscape))

#### Enrichment Analysis ####

# Function to perform enrichment analysis (GO, KEGG, Reactome)
perform_enrichment_analysis <- function(cluster_df, background_ids, min_size = 5, enrichment_type = "GO") {
  results <- list()
  
  filtered_clusters <- cluster_df %>%
    group_by(Cluster_Number) %>%
    summarise(Protein_Count = n()) %>%
    filter(Protein_Count >= min_size)
  
  for (cluster_num in filtered_clusters$Cluster_Number) {
    protein_ids <- cluster_df %>%
      filter(Cluster_Number == cluster_num) %>%
      pull(Uniprot_ID)
    
    if (enrichment_type == "GO") {
      ego <- enrichGO(
        gene = protein_ids,
        OrgDb = org.Hs.eg.db,
        keyType = "UNIPROT",
        ont = "BP",
        pAdjustMethod = "BH",
        universe = background_ids,
        qvalueCutoff = 0.05,
        minGSSize = 10,
        maxGSSize = 100,
        readable = TRUE
      )
      
      top_terms <- ego@result %>%
        arrange(p.adjust) %>%
        head(3)
      
    } else if (enrichment_type == "KEGG") {
      entrez_mapping <- bitr(protein_ids, fromType = "UNIPROT", toType = "ENTREZID", OrgDb = org.Hs.eg.db)
      entrez_ids <- entrez_mapping$ENTREZID
      
      ekegg <- enrichKEGG(
        gene = entrez_ids,
        organism = "hsa",
        keyType = "kegg",
        pAdjustMethod = "BH",
        universe = background_ids,
        qvalueCutoff = 0.05,
        minGSSize = 5,
        maxGSSize = 100
      )
      
      top_terms <- ekegg@result %>%
        arrange(p.adjust) %>%
        head(3)
      
    } else if (enrichment_type == "Reactome") {
      entrez_mapping <- bitr(protein_ids, fromType = "UNIPROT", toType = "ENTREZID", OrgDb = org.Hs.eg.db)
      
      ereactome <- enrichPathway(
        gene = entrez_mapping$ENTREZID,
        organism = "human",
        pAdjustMethod = "BH",
        universe = background_ids,
        qvalueCutoff = 0.05,
        minGSSize = 5,
        maxGSSize = 200,
        readable = TRUE
      )
      
      top_terms <- ereactome@result %>%
        arrange(p.adjust) %>%
        head(3)
      
    } else {
      stop("Invalid enrichment type specified.")
    }
    
    results[[as.character(cluster_num)]] <- top_terms
  }
  
  return(results)
}

# Example usage of enrichment analysis:
background_ids <- unique(cluster_df_mcl$Uniprot_ID)

# GO Enrichment
go_results <- perform_enrichment_analysis(cluster_df_mcl, background_ids, enrichment_type = "GO")
for (cluster_num in names(go_results)) {
  cat("\nCluster:", cluster_num, "\n")
  print(go_results[[cluster_num]][, c("ID", "Description", "p.adjust")])
}

# KEGG Enrichment
kegg_results <- perform_enrichment_analysis(cluster_df_mcl, background_ids, enrichment_type = "KEGG")
for (cluster_num in names(kegg_results)) {
  cat("\nCluster:", cluster_num, "\n")
  print(kegg_results[[cluster_num]][, c("ID", "Description", "p.adjust")])
}

# Reactome Enrichment
reactome_results <- perform_enrichment_analysis(cluster_df_mcl, background_ids, enrichment_type = "Reactome")
for (cluster_num in names(reactome_results)) {
  cat("\nCluster:", cluster_num, "\n")
  print(reactome_results[[cluster_num]][, c("ID", "Description", "p.adjust")])
}
